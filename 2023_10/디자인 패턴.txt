abstract factory
구체적인 클래스에 의존x, 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스 제공. 동일 주제의 다른 팩토리 묶음.

factory method
상위클래스에서 객체 생성하는 인터페이스 정의, 하위 클래스에서 인스턴스 생성.
인터페이스의 실제 객체를 생성하는 클래스를 분리. 캡슐화
가상생성자 패턴

composite
객체들의 관계를 트리구조를 구성해 부분-전체 계층을 표현
사용자가 단일 객체와 복합 객체 모두 동일하게 다룰 수 있게 함.
객체를 묶어 하나의 객체로 이용가능
복합객체와 단일객체를 클라이언트에서 구별없이 다루게 함.

decorator
기존에 구현된 클래스에 필요한 기능을 추가.
객체간의 결합을 통해 기능을 동적으로 유연하게 확장. 상속의 대안.
새 행동을 추가/오버라이드 가능

facade
복잡한 시스템에 대해 단순한(상위에) 인터페이스 제공. 사용자의 시스템 간 또는 다른 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악이 쉬움.
오류에 대해 단위 별로 확인 가능. 
사용자) 단순한 인터페이스->접근성 
통합된 인터페이스 제공(wrapper 객체 필요)

flyweight
다수의 (유사)객체로 생성(/조작)될 경우 모두가 갖는 본질적인 요소를 클래스화하여 공유. 
메모리 절약, 클래스 경량화.
여러개의 가상 인스턴스 제공.

proxy
실제 객체에 대한 대리 객체. 실제 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들고, 미리 할당하지 않아도 상관없는 것들을 실제로 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있음. (인터페이스 역할을 수행)
정보은닉 기능.
접근조절, 비용절감, 복잡도 감소를 위해 접근이 힘든 객체에 대한 대역 제공
(네트워크 연결, 메모리의 대용량객체로의 접근에 이용.)

command
추상클래스에 메서드를 만들어, 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행됨
실행된 기능을 캡슐화함으로써 주어진 여러 기능을 실핼할 수 있는 재사용성 높은 클래스를 설계하는 패턴.
요구사항을 객체로 캡슐화
(요청에 필요한 정보를 저장하거나 로그를 남기는 패턴.
요청에 사용되는 각종 명령어들을 추상 클래스와 구체클래스로 분리.)

chain of responsibility
정적으로 어떤 기능에 대한 처리의 연결이 하드코딩되어 있을 때, 기능 처리의 연결 변경이 불가능한데, 이를 동적으로 연결한 경우에는 다르게 처리할 수 있도록 하는 디자인 패턴.
한 요청을 2개 이상의 객체에서 처리.
(한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태)

observer
어떤 클래스에 변화가 일어났을 때 이를 감지해 다른 클래스(상속)에 통보+내용 갱신
일대다의 의존성. 상호작용하는 객체 사이에서 가능한, 느슨하게 결합하는 디자인 패턴
(분산된 시스템 간에 이벤트 생성, 발행, 수신)

template method
상위클래스에서는 추상적으로 표현, 구체적인 내용은 하위 클래스에서 결정
작업을 처리하는 일부분을 서브 클래스로 캡슐화. 전체 일을 수행하는 구조(상위 작업)는 바꾸지 않으면서, 특정 단계에서 수행하는 내용을 변경.
(상위 클래스에서 골격을 정의, 하위 클래스에서 세부 처리를 구체화)
(유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의, 코드 줄이고 유지보수 편하게)

mediator
객체의 수가 너무 많아져 통신이 복잡해지면 느슨한 결합을 해칠 수 있기 때문에 중간에서 이를 통제하고 지시할 수 있는 역할(중재자)
중재자에게 요구하여 통신의 빈도를 줄임
상호작용의 유연한 변경을 지원
(객체들 사이의 복잡한 상호작용(인터페이스)을 캡슐화, 객체로 정의)
(객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음)

iterator
컬렉션 구현 방법은 노출시키지 않으며, 그 집합체 안에 들어있는 모든 항목에 접근할 방법을 제공하는 패턴
내부구조 노출x, 복합 객체의 원소를 순차적으로 접근 가능하게 하는 행위 패턴.
(자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용)

state
객체 상태를 캡슐화해서 클래스화, 그것을 참조하는 방식
상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경, 변경시 원시 코드의 수정을 최소화할 수 있고, 유지보수의 편의성도 가짐
객체의 상태에 따라 행위 내용을 변경

visitor 
각 클래스의 데이터 구조로부터 처리기능을 분리, 별도의 클래스 생성.
해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행.
객체 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장.
특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원

strategy
알고리즘 군을 정의(추상클래스). 같은 알고리즘을 각각 하나의 클래스로 캡슐화.
필요할 때 서로 교환해서 사용할 수 있게 하는 패턴
행위 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
(클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용. 
클라이언트에 영향 없이 알고리즘 변경 가능)

memento
클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용.
undo 기능을 개발할 때 사용.
(특정 시점에서의 객체 내부 상태를 객체화)